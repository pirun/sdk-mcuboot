From 9a227870d3e7c3bfdf5aaff629d2dfeff279607c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Luk=C3=A1=C5=A1=20Kopenec?= <lukas.kopenec@cloufield.cz>
Date: Mon, 6 Apr 2020 21:19:42 +0200
Subject: [PATCH 1/8] Attach SDHC to SPI2.

---
 boot/zephyr/boards/nrf52_pca10040.overlay | 10 ++++
 boot/zephyr/main.c                        | 61 +++++++++++++++++++++++
 boot/zephyr/prj.conf                      | 17 ++++++-
 3 files changed, 87 insertions(+), 1 deletion(-)
 create mode 100644 boot/zephyr/boards/nrf52_pca10040.overlay

diff --git a/boot/zephyr/boards/nrf52_pca10040.overlay b/boot/zephyr/boards/nrf52_pca10040.overlay
new file mode 100644
index 000000000..e6458a8db
--- /dev/null
+++ b/boot/zephyr/boards/nrf52_pca10040.overlay
@@ -0,0 +1,10 @@
+&spi2 {
+    compatible = "nordic,nrf-spim";
+    sdhc0: sdhc@0 {
+        compatible = "zephyr,mmc-spi-slot";
+        reg = <0>;
+        status = "okay";
+        label = "SDHC0";
+        spi-max-frequency = <8000000>;
+    };
+};
diff --git a/boot/zephyr/main.c b/boot/zephyr/main.c
index f4374e60b..7aa280ed8 100644
--- a/boot/zephyr/main.c
+++ b/boot/zephyr/main.c
@@ -21,6 +21,11 @@
 #include <drivers/flash.h>
 #include <drivers/timer/system_timer.h>
 #include <usb/usb_device.h>
+#include <device.h>
+#include <disk/disk_access.h>
+#include <fs/fs.h>
+#include <ff.h>
+#include <devicetree.h>
 #include <soc.h>
 
 #include "target.h"
@@ -175,6 +180,15 @@ static void do_boot(struct boot_rsp *rsp)
 }
 #endif
 
+static FATFS fat_fs;
+/* mounting info */
+static struct fs_mount_t mp = {
+	.type = FS_FATFS,
+	.fs_data = &fat_fs,
+};
+
+static const char *disk_mount_pt = "/SD:";
+
 void main(void)
 {
     struct boot_rsp rsp;
@@ -248,6 +262,53 @@ void main(void)
     }
 #endif
 
+    /* raw disk i/o */
+	do {
+		static const char *disk_pdrv = "SD";
+		u64_t memory_size_mb;
+		u32_t block_count;
+		u32_t block_size;
+        int err = 0;
+
+        BOOT_LOG_INF("#1");
+		if ((err = disk_access_init(disk_pdrv)) != 0) {
+			BOOT_LOG_ERR("Storage init ERROR! %d", err);
+			break;
+		}
+        BOOT_LOG_INF("#2");
+
+		if (disk_access_ioctl(disk_pdrv,
+				DISK_IOCTL_GET_SECTOR_COUNT, &block_count)) {
+			BOOT_LOG_ERR("Unable to get sector count");
+			break;
+		}
+		BOOT_LOG_INF("Block count %u", block_count);
+
+		if (disk_access_ioctl(disk_pdrv,
+				DISK_IOCTL_GET_SECTOR_SIZE, &block_size)) {
+			BOOT_LOG_ERR("Unable to get sector size");
+			break;
+		}
+		BOOT_LOG_INF("Sector size %u\n", block_size);
+
+		memory_size_mb = (u64_t)block_count * block_size;
+		BOOT_LOG_INF("Memory Size(MB) %u\n", (u32_t)memory_size_mb>>20);
+	} while (0);
+
+	mp.mnt_point = disk_mount_pt;
+
+	int res = fs_mount(&mp);
+
+	if (res == FR_OK) {
+		BOOT_LOG_INF("Disk mounted.\n");
+	} else {
+		BOOT_LOG_ERR("Error mounting disk.\n");
+	}
+
+	while (1) {
+		k_sleep(K_MSEC(1000));
+	}
+
     rc = boot_go(&rsp);
     if (rc != 0) {
         BOOT_LOG_ERR("Unable to find bootable image");
diff --git a/boot/zephyr/prj.conf b/boot/zephyr/prj.conf
index 808d317af..9bf970076 100644
--- a/boot/zephyr/prj.conf
+++ b/boot/zephyr/prj.conf
@@ -47,4 +47,19 @@ CONFIG_FLASH=y
 CONFIG_LOG=y
 CONFIG_LOG_IMMEDIATE=y
 ### Ensure Zephyr logging changes don't use more resources
-CONFIG_LOG_DEFAULT_LEVEL=0
+CONFIG_LOG_DEFAULT_LEVEL=3
+
+### SPI SDHC drivers rely on multithreading
+CONFIG_MULTITHREADING=y
+
+CONFIG_SPI=y
+CONFIG_SPI_2=y
+CONFIG_SPI_NRFX_RAM_BUFFER_SIZE=8
+CONFIG_SPI_2_NRF_SPIM=y
+CONFIG_NRFX_SPIM2=y
+CONFIG_NRF52832_SPIM_PAN58_WORKAROUND=y
+CONFIG_DISK_ACCESS=y
+CONFIG_DISK_ACCESS_SDHC=y
+CONFIG_DISK_ACCESS_SPI_SDHC=y
+CONFIG_FILE_SYSTEM=y
+CONFIG_FAT_FILESYSTEM_ELM=y

From 268562f736840391d70ab0e7b53dcdac67d9aee6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Luk=C3=A1=C5=A1=20Kopenec?= <lukas.kopenec@cloufield.cz>
Date: Wed, 15 Apr 2020 08:17:38 +0200
Subject: [PATCH 2/8] Ignore VS Code files.

---
 .gitignore | 1 +
 1 file changed, 1 insertion(+)

diff --git a/.gitignore b/.gitignore
index 4169afcd1..02ebe16a9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -15,6 +15,7 @@ rusty-tags.*
 #Eclipse project files
 .cproject
 .project
+.vscode
 
 # Compiled python modules.
 *.pyc

From df3ddd3689e3811c7601ec34b73d937d51f0f327 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Luk=C3=A1=C5=A1=20Kopenec?= <lukas.kopenec@cloufield.cz>
Date: Mon, 20 Apr 2020 11:09:51 +0200
Subject: [PATCH 3/8] Step back to legacy SPI drivers.

---
 boot/zephyr/boards/nrf52_pca10040.overlay |  2 +-
 boot/zephyr/prj.conf                      | 12 ++++++------
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/boot/zephyr/boards/nrf52_pca10040.overlay b/boot/zephyr/boards/nrf52_pca10040.overlay
index e6458a8db..764ac8b28 100644
--- a/boot/zephyr/boards/nrf52_pca10040.overlay
+++ b/boot/zephyr/boards/nrf52_pca10040.overlay
@@ -1,5 +1,5 @@
 &spi2 {
-    compatible = "nordic,nrf-spim";
+    compatible = "nordic,nrf-spi";
     sdhc0: sdhc@0 {
         compatible = "zephyr,mmc-spi-slot";
         reg = <0>;
diff --git a/boot/zephyr/prj.conf b/boot/zephyr/prj.conf
index 9bf970076..354edbfaa 100644
--- a/boot/zephyr/prj.conf
+++ b/boot/zephyr/prj.conf
@@ -47,19 +47,19 @@ CONFIG_FLASH=y
 CONFIG_LOG=y
 CONFIG_LOG_IMMEDIATE=y
 ### Ensure Zephyr logging changes don't use more resources
-CONFIG_LOG_DEFAULT_LEVEL=3
+CONFIG_LOG_DEFAULT_LEVEL=0
 
 ### SPI SDHC drivers rely on multithreading
 CONFIG_MULTITHREADING=y
 
+CONFIG_MCUBOOT_SD_UPDATE=y
+
 CONFIG_SPI=y
 CONFIG_SPI_2=y
-CONFIG_SPI_NRFX_RAM_BUFFER_SIZE=8
-CONFIG_SPI_2_NRF_SPIM=y
-CONFIG_NRFX_SPIM2=y
-CONFIG_NRF52832_SPIM_PAN58_WORKAROUND=y
+CONFIG_NRFX_SPI2=y
+CONFIG_SPI_2_NRF_SPI=y
 CONFIG_DISK_ACCESS=y
 CONFIG_DISK_ACCESS_SDHC=y
 CONFIG_DISK_ACCESS_SPI_SDHC=y
 CONFIG_FILE_SYSTEM=y
-CONFIG_FAT_FILESYSTEM_ELM=y
+CONFIG_FAT_FILESYSTEM_ELM=y
\ No newline at end of file

From 8f8a8f64c1688e9435a994c672779ae42ff4e6cb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Luk=C3=A1=C5=A1=20Kopenec?= <lukas.kopenec@cloufield.cz>
Date: Mon, 20 Apr 2020 11:10:42 +0200
Subject: [PATCH 4/8] Implement update from SD card.

---
 boot/zephyr/CMakeLists.txt      |   4 +
 boot/zephyr/Kconfig             |  30 +++
 boot/zephyr/include/sd_update.h |  29 ++
 boot/zephyr/main.c              |  77 ++----
 boot/zephyr/prj.conf            |   2 -
 boot/zephyr/sd_update.c         | 450 ++++++++++++++++++++++++++++++++
 6 files changed, 530 insertions(+), 62 deletions(-)
 create mode 100644 boot/zephyr/include/sd_update.h
 create mode 100644 boot/zephyr/sd_update.c

diff --git a/boot/zephyr/CMakeLists.txt b/boot/zephyr/CMakeLists.txt
index cc400f938..1d6f8f361 100644
--- a/boot/zephyr/CMakeLists.txt
+++ b/boot/zephyr/CMakeLists.txt
@@ -188,6 +188,10 @@ if(CONFIG_BOOT_ENCRYPT_EC256)
     )
 endif()
 
+if(CONFIG_MCUBOOT_SD_UPDATE)
+  zephyr_library_sources(sd_update.c)
+endif()
+
 if(CONFIG_MCUBOOT_SERIAL)
   zephyr_sources(${BOOT_DIR}/zephyr/serial_adapter.c)
   zephyr_sources(${BOOT_DIR}/boot_serial/src/boot_serial.c)
diff --git a/boot/zephyr/Kconfig b/boot/zephyr/Kconfig
index a5009e4a2..3fdd154d2 100644
--- a/boot/zephyr/Kconfig
+++ b/boot/zephyr/Kconfig
@@ -246,6 +246,36 @@ module = MCUBOOT
 module-str = MCUBoot bootloader
 source "subsys/logging/Kconfig.template.log_config"
 
+menuconfig MCUBOOT_SD_UPDATE
+	bool "MCUboot firmware update from SD card"
+	default n
+	select FILE_SYSTEM
+	select FAT_FILESYSTEM_ELM
+	help
+		If y, enables updating the image from an SD card.
+
+if MCUBOOT_SD_UPDATE
+
+config SD_UPDATE_MOUNT_POINT
+	string "SD card mount point"
+	default "/SD:"
+	help
+		Indicates where the SD card will be mounted.
+
+config SD_UPDATE_IMAGE_FILE_NAME
+	string "Name of the image update file"
+	default "UPDATE.BIN"
+	help
+		Name of the file containing the image update.
+
+config SD_UPDATE_BACKUP_FILE_NAME
+	string "Name of the image backup file"
+	default "BACKUP.BIN"
+	help
+		Name of the file to which the backup of the current image will be written.
+
+endif	# MCUBOOT_SD_UPDATE
+
 menuconfig MCUBOOT_SERIAL
 	bool "MCUboot serial recovery"
 	default n
diff --git a/boot/zephyr/include/sd_update.h b/boot/zephyr/include/sd_update.h
new file mode 100644
index 000000000..0a2e9b2c2
--- /dev/null
+++ b/boot/zephyr/include/sd_update.h
@@ -0,0 +1,29 @@
+#ifndef H_SD_UPDATE_SD
+#define H_SD_UPDATE_SD
+
+#include <fs/fs.h>
+
+#include "bootutil/image.h"
+
+struct sd_update {
+    struct image_header header;
+    struct fs_file_t update_file;
+};
+
+int init_sd();
+
+int check_sd_update(struct sd_update *update);
+
+int validate_update_image(struct sd_update *update);
+
+int backup_firmware();
+
+int write_update(struct sd_update *update);
+
+int revert_update();
+
+int cleanup_update(struct sd_update *update);
+
+bool do_sd_update();
+
+#endif
diff --git a/boot/zephyr/main.c b/boot/zephyr/main.c
index 7aa280ed8..8b9ce65b7 100644
--- a/boot/zephyr/main.c
+++ b/boot/zephyr/main.c
@@ -21,11 +21,6 @@
 #include <drivers/flash.h>
 #include <drivers/timer/system_timer.h>
 #include <usb/usb_device.h>
-#include <device.h>
-#include <disk/disk_access.h>
-#include <fs/fs.h>
-#include <ff.h>
-#include <devicetree.h>
 #include <soc.h>
 
 #include "target.h"
@@ -35,6 +30,10 @@
 #include "bootutil/bootutil.h"
 #include "flash_map_backend/flash_map_backend.h"
 
+#ifdef CONFIG_MCUBOOT_SD_UPDATE
+#include "sd_update.h"
+#endif
+
 #ifdef CONFIG_MCUBOOT_SERIAL
 #include "boot_serial/boot_serial.h"
 #include "serial_adapter/serial_adapter.h"
@@ -180,15 +179,6 @@ static void do_boot(struct boot_rsp *rsp)
 }
 #endif
 
-static FATFS fat_fs;
-/* mounting info */
-static struct fs_mount_t mp = {
-	.type = FS_FATFS,
-	.fs_data = &fat_fs,
-};
-
-static const char *disk_mount_pt = "/SD:";
-
 void main(void)
 {
     struct boot_rsp rsp;
@@ -262,54 +252,21 @@ void main(void)
     }
 #endif
 
-    /* raw disk i/o */
-	do {
-		static const char *disk_pdrv = "SD";
-		u64_t memory_size_mb;
-		u32_t block_count;
-		u32_t block_size;
-        int err = 0;
-
-        BOOT_LOG_INF("#1");
-		if ((err = disk_access_init(disk_pdrv)) != 0) {
-			BOOT_LOG_ERR("Storage init ERROR! %d", err);
-			break;
-		}
-        BOOT_LOG_INF("#2");
-
-		if (disk_access_ioctl(disk_pdrv,
-				DISK_IOCTL_GET_SECTOR_COUNT, &block_count)) {
-			BOOT_LOG_ERR("Unable to get sector count");
-			break;
-		}
-		BOOT_LOG_INF("Block count %u", block_count);
-
-		if (disk_access_ioctl(disk_pdrv,
-				DISK_IOCTL_GET_SECTOR_SIZE, &block_size)) {
-			BOOT_LOG_ERR("Unable to get sector size");
-			break;
-		}
-		BOOT_LOG_INF("Sector size %u\n", block_size);
-
-		memory_size_mb = (u64_t)block_count * block_size;
-		BOOT_LOG_INF("Memory Size(MB) %u\n", (u32_t)memory_size_mb>>20);
-	} while (0);
-
-	mp.mnt_point = disk_mount_pt;
-
-	int res = fs_mount(&mp);
-
-	if (res == FR_OK) {
-		BOOT_LOG_INF("Disk mounted.\n");
-	} else {
-		BOOT_LOG_ERR("Error mounting disk.\n");
-	}
-
-	while (1) {
-		k_sleep(K_MSEC(1000));
-	}
+#ifdef CONFIG_MCUBOOT_SD_UPDATE
+    bool updated = do_sd_update();
+#endif
 
     rc = boot_go(&rsp);
+    #ifdef CONFIG_MCUBOOT_SD_UPDATE
+        if (rc != 0 && updated) {
+            BOOT_LOG_INF("Failed to boot updated firmware, attemptin revert...");
+            int res = revert_update();
+            if (res == 0) {
+                BOOT_LOG_INF("Revert successful, booting original firmware");
+                rc = boot_go(&rsp);
+            }
+        }
+    #endif
     if (rc != 0) {
         BOOT_LOG_ERR("Unable to find bootable image");
         while (1)
diff --git a/boot/zephyr/prj.conf b/boot/zephyr/prj.conf
index 354edbfaa..e096d9d81 100644
--- a/boot/zephyr/prj.conf
+++ b/boot/zephyr/prj.conf
@@ -61,5 +61,3 @@ CONFIG_SPI_2_NRF_SPI=y
 CONFIG_DISK_ACCESS=y
 CONFIG_DISK_ACCESS_SDHC=y
 CONFIG_DISK_ACCESS_SPI_SDHC=y
-CONFIG_FILE_SYSTEM=y
-CONFIG_FAT_FILESYSTEM_ELM=y
\ No newline at end of file
diff --git a/boot/zephyr/sd_update.c b/boot/zephyr/sd_update.c
new file mode 100644
index 000000000..5a1ba9887
--- /dev/null
+++ b/boot/zephyr/sd_update.c
@@ -0,0 +1,450 @@
+#include <ctype.h>
+#include <disk/disk_access.h>
+#include <drivers/flash.h>
+#include <errno.h>
+#include <ff.h>
+#include <stddef.h>
+
+#include "bootutil/bootutil_log.h"
+#include "bootutil/image.h"
+#include "bootutil/sha256.h"
+#include "flash_map_backend/flash_map_backend.h"
+#include "sd_update.h"
+
+MCUBOOT_LOG_MODULE_REGISTER(sd_update);
+
+#define PATH_SEPARATOR "/"
+#define UPDATE_FILE CONFIG_SD_UPDATE_MOUNT_POINT PATH_SEPARATOR CONFIG_SD_UPDATE_IMAGE_FILE_NAME
+#define BACKUP_FILE CONFIG_SD_UPDATE_MOUNT_POINT PATH_SEPARATOR CONFIG_SD_UPDATE_BACKUP_FILE_NAME
+
+static FATFS fat_fs;
+/* mounting info */
+static struct fs_mount_t mp = {
+    .type = FS_FATFS,
+    .fs_data = &fat_fs,
+};
+
+int init_sd() {
+    static const char *disk_pdrv = "SD";
+    int err = disk_access_init(disk_pdrv);
+
+    if (err) {
+        BOOT_LOG_ERR("Failed to initialize SD card (%d)", err);
+        return err;
+    }
+
+    mp.mnt_point = CONFIG_SD_UPDATE_MOUNT_POINT;
+    err = fs_mount(&mp);
+    if (err == FR_OK) {
+        BOOT_LOG_INF("SD Card mounted");
+    } else {
+        BOOT_LOG_ERR("Failed to mount SD card (%d)", err);
+    }
+
+    return err;
+}
+
+int strcasecmp(const char *s1, const char *s2)
+{
+	const unsigned char *us1 = (const unsigned char *)s1;
+	const unsigned char *us2 = (const unsigned char *)s2;
+
+	while (tolower(*us1) == tolower(*us2++))
+		if (*us1++ == '\0')
+			return 0;
+	return tolower(*us1) - tolower(*--us2);
+}
+
+int check_sd_update(struct sd_update *update) {
+    if (!update) {
+        return -EINVAL;
+    }
+
+    int res;
+    struct fs_dir_t dirp;
+    static struct fs_dirent entry;
+    bool has_update = false;
+
+    res = fs_opendir(&dirp, CONFIG_SD_UPDATE_MOUNT_POINT);
+    if (res) {
+        BOOT_LOG_ERR("Error opening dir %s [%d]\n", CONFIG_SD_UPDATE_MOUNT_POINT, res);
+        return res;
+    }
+
+    for (;;) {
+        res = fs_readdir(&dirp, &entry);
+
+        if (res || entry.name[0] == 0) {
+            break;
+        }
+
+        if (entry.type == FS_DIR_ENTRY_FILE && strcasecmp(entry.name, CONFIG_SD_UPDATE_IMAGE_FILE_NAME) == 0) {
+            has_update = true;
+            break;
+        }
+    }
+
+    fs_closedir(&dirp);
+
+    if (!has_update) {
+        BOOT_LOG_INF("No update file found on the SD card");
+        return -ENOENT;
+    }
+
+    res = fs_open(&update->update_file, UPDATE_FILE);
+    if (res) {
+        BOOT_LOG_ERR("Failed to open the update image (%d)", res);
+        return res;
+    }
+
+    res = fs_read(&update->update_file, &update->header, sizeof(update->header));
+    if (res < sizeof(&update->header)) {
+        BOOT_LOG_ERR("Failed to read update header (%d)", res);
+        fs_close(&update->update_file);
+        return res;
+    }
+
+    if (update->header.ih_magic != IMAGE_MAGIC) {
+        BOOT_LOG_ERR("The update does not contain a valid image");
+        fs_close(&update->update_file);
+        return res;
+    }
+
+    fs_seek(&update->update_file, 0, FS_SEEK_SET);
+
+    return 0;
+}
+
+static int get_update_hash(struct sd_update *update, uint8_t *hash_result) {
+    bootutil_sha256_context sha256_ctx;
+
+    bootutil_sha256_init(&sha256_ctx);
+
+    const size_t tmp_buf_sz = 256;
+    uint8_t tmpbuf[tmp_buf_sz];
+
+    int res;
+    size_t remains = update->header.ih_hdr_size;
+    remains += update->header.ih_img_size;
+    remains += update->header.ih_protect_tlv_size;
+
+    while (remains > 0) {
+        res = fs_read(&update->update_file, tmpbuf, tmp_buf_sz < remains ? tmp_buf_sz : remains);
+        if (res < 0) {
+            return res;
+        }
+        bootutil_sha256_update(&sha256_ctx, tmpbuf, res);
+        remains -= res;
+    }
+
+    bootutil_sha256_finish(&sha256_ctx, hash_result);
+
+    return 0;
+}
+
+struct tlv_iterator {
+    struct fs_file_t *update_file;
+    off_t end;
+    off_t offset;
+};
+
+static int tlv_iter_begin(struct sd_update *update, struct tlv_iterator *it) {
+    off_t offset = update->header.ih_hdr_size + update->header.ih_img_size;
+    struct image_tlv_info info;
+    int res = fs_seek(&update->update_file, offset, FS_SEEK_SET);
+    if (res) {
+        return res;
+    }
+    res = fs_read(&update->update_file, &info, sizeof(info));
+    if (res < sizeof(info)) {
+        return -EIO;
+    }
+
+    if (info.it_magic == IMAGE_TLV_PROT_INFO_MAGIC) {
+        if (update->header.ih_protect_tlv_size != info.it_tlv_tot) {
+            return -1;
+        }
+
+        offset += info.it_tlv_tot;
+        res = fs_seek(&update->update_file, offset, FS_SEEK_SET);
+        if (res) {
+            return res;
+        }
+        res = fs_read(&update->update_file, &info, sizeof(info));
+        if (res < sizeof(info)) {
+            return -EIO;
+        }
+    } else if (update->header.ih_protect_tlv_size != 0) {
+        return -1;
+    }
+
+    if (info.it_magic != IMAGE_TLV_INFO_MAGIC) {
+        return -1;
+    }
+
+    it->update_file = &update->update_file;
+    it->offset = offset + sizeof(info);
+    it->end = offset + info.it_tlv_tot;
+
+    return 0;
+}
+
+static int tlv_iter_next(struct tlv_iterator *it, off_t *offset, uint16_t *type, uint16_t *len) {
+    struct image_tlv tlv;
+
+    if (it == NULL || it->update_file == NULL) {
+        return -1;
+    }
+
+    while (it->offset < it->end) {
+        int res = fs_seek(it->update_file, it->offset, FS_SEEK_SET);
+        if (res) {
+            return res;
+        }
+        res = fs_read(it->update_file, &tlv, sizeof(tlv));
+        if (res < sizeof(tlv)) {
+            return -EIO;
+        }
+
+        *type = tlv.it_type;
+        *len = tlv.it_len;
+        *offset = it->offset + sizeof(tlv);
+        it->offset += sizeof(tlv) + tlv.it_len;
+        return 0;
+    }
+
+    return 1;
+}
+
+int validate_update_image(struct sd_update *update)
+{
+    uint8_t hash[32];
+    uint8_t buf[32];
+    int res;
+
+    BOOT_LOG_INF("Found update image, validating...");
+
+    res = get_update_hash(update, hash);
+    if (res) {
+        BOOT_LOG_ERR("Failed to compute image hash (%d)", res);
+        return res;
+    }
+
+    struct tlv_iterator it;
+    res = tlv_iter_begin(update, &it);
+    if (res) {
+        BOOT_LOG_ERR("Failed to read update image TLVs (%d)", res);
+        return res;
+    }
+
+    while (true) {
+        off_t offset;
+        uint16_t type;
+        uint16_t len;
+        res = tlv_iter_next(&it, &offset, &type, &len);
+        if (res < 0) {
+            BOOT_LOG_ERR("Failed to read update image TLV (%d)", res);
+            return res;
+        } else if (res > 0) {
+            break;
+        }
+        if (type == IMAGE_TLV_SHA256) {
+            if (len != sizeof(hash)) {
+                BOOT_LOG_ERR("Incorrect update hash size");
+                return -1;
+            }
+            res = fs_read(&update->update_file, buf, sizeof(hash));
+            if (res < sizeof(hash)) {
+                BOOT_LOG_ERR("Failed to read update hash (%d)", res);
+                return res;
+            }
+            if (memcmp(hash, buf, sizeof(hash))) {
+                BOOT_LOG_ERR("Incorrect update hash");
+                return -1;
+            }
+            BOOT_LOG_INF("Update image is valid");
+            return 0;
+        }
+    }
+
+    BOOT_LOG_ERR("Failed to find update hash");
+    return -1;
+}
+
+int backup_firmware() {
+    const struct flash_area *fap;
+    size_t buf_size = 256;
+    uint8_t buf[buf_size];
+    struct fs_file_t backup;
+    int area_id;
+    int res;
+
+    BOOT_LOG_INF("Backing up current firmware...");
+
+    fs_unlink(BACKUP_FILE);
+
+    area_id = flash_area_id_from_image_slot(0);
+    res = flash_area_open(area_id, &fap);
+    if (res) {
+        BOOT_LOG_ERR("Failed to open the primary slot (%d)", res);
+        goto done2;
+    }
+
+    res = fs_open(&backup, BACKUP_FILE);
+    if (res) {
+        BOOT_LOG_ERR("Failed to create backup file on SD (%d)", res);
+        goto done2;
+    }
+
+    size_t remains = fap->fa_size;
+    off_t offset = 0;
+    while (remains > 0) {
+        size_t num_bytes = buf_size > remains ? remains : buf_size;
+        res = flash_area_read(fap, offset, buf, num_bytes);
+        if (res) {
+            BOOT_LOG_ERR("Failed to read flash data (%d)", res);
+            goto done;
+        }
+        res = fs_write(&backup, buf, num_bytes);
+        if (res != num_bytes) {
+            BOOT_LOG_ERR("Failed to write backup data (%d)", res);
+            goto done;
+        }
+
+        remains -= num_bytes;
+        offset += num_bytes;
+    }
+    res = 0;
+    BOOT_LOG_INF("Backup complete");
+
+done:
+    fs_close(&backup);
+done2:
+    flash_area_close(fap);
+    return res;
+}
+
+static int write_image(struct fs_file_t *file) {
+    const struct flash_area *fap;
+    size_t buf_size = 256;
+    uint8_t buf[buf_size];
+    int area_id;
+    int res;
+
+    BOOT_LOG_INF("Writing image to flash...");
+
+    area_id = flash_area_id_from_image_slot(0);
+    res = flash_area_open(area_id, &fap);
+    if (res) {
+        BOOT_LOG_ERR("Failed to open the primary slot (%d)", res);
+        return res;
+    }
+
+    res = flash_area_erase(fap, 0, fap->fa_size);
+    if (res) {
+        BOOT_LOG_ERR("Failed to erase flash memory (%d)", res);
+        goto done;
+    }
+
+    off_t offset = 0;
+    size_t read = 0;
+    do {
+        read = fs_read(file, buf, buf_size);
+        if (read < 0) {
+            BOOT_LOG_ERR("Failed to read file data (%d)", res);
+            goto done;
+        }
+        if (read < buf_size) {
+            memset(buf + read, 0xFF, buf_size - read);
+        }
+        res = flash_area_write(fap, offset, buf, buf_size);
+        if (res) {
+            BOOT_LOG_ERR("Failed to write flash data (%d)", res);
+            goto done;
+        }
+
+        offset += read;
+    } while (read == buf_size);
+    res = 0;
+    BOOT_LOG_INF("Image written successfully");
+
+done:
+    flash_area_close(fap);
+    return res;
+}
+
+int write_update(struct sd_update *update) {
+    int res = fs_seek(&update->update_file, 0, FS_SEEK_SET);
+    if (res) {
+        BOOT_LOG_ERR("Failed to seek at the beggining of the update file (%d)", res);
+        return res;
+    }
+
+    return write_image(&update->update_file);
+}
+
+int revert_update() {
+    struct fs_file_t backup;
+    int res = fs_open(&backup, BACKUP_FILE);
+    if (res) {
+        BOOT_LOG_ERR("Failed to open the backup file (%d)", res);
+        return res;
+    }
+
+    res = write_image(&backup);
+    fs_close(&backup);
+
+    return res;
+}
+
+int cleanup_update(struct sd_update *update) {
+    fs_close(&update->update_file);
+    return fs_unmount(&mp);
+}
+
+bool do_sd_update() {
+    BOOT_LOG_INF("Starting SD update...");
+    int res;
+    struct sd_update update;
+    bool updated = false;
+
+    res = init_sd();
+    if (res) {
+        return updated;
+    }
+
+    res = check_sd_update(&update);
+    if (res) {
+        goto cleanup;
+    }
+
+    res = validate_update_image(&update);
+    if (res) {
+        BOOT_LOG_ERR("Failed update image validation (%d)", res);
+        goto cleanup;
+    }
+
+    res = backup_firmware();
+    if (res) {
+        BOOT_LOG_ERR("Could not backup current firmware, update won't continue. (%d)", res);
+        goto cleanup;
+    }
+
+    res = write_update(&update);
+    if (res) {
+        BOOT_LOG_WRN("Failed to write update, attempting revert...");
+        res = revert_update();
+        if (res) {
+            BOOT_LOG_ERR("Revert failed");
+        } else {
+            BOOT_LOG_INF("Revert successful, update has not been done");
+        }
+    } else {
+        updated = true;
+    }
+
+cleanup:
+    cleanup_update(&update);
+    BOOT_LOG_INF("SD update finished");
+    return updated;
+}

From 24c989dcf6701b393b16182c28aae28acea4bc80 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Luk=C3=A1=C5=A1=20Kopenec?= <lukas.kopenec@cloufield.cz>
Date: Tue, 21 Apr 2020 10:45:14 +0200
Subject: [PATCH 5/8] Improvements:

 - Configurable update directory
 - Unlink the update file after successful update.
---
 boot/zephyr/Kconfig             |  6 ++++++
 boot/zephyr/include/sd_update.h |  2 +-
 boot/zephyr/sd_update.c         | 21 ++++++++++++++-------
 3 files changed, 21 insertions(+), 8 deletions(-)

diff --git a/boot/zephyr/Kconfig b/boot/zephyr/Kconfig
index 3fdd154d2..57b1199a6 100644
--- a/boot/zephyr/Kconfig
+++ b/boot/zephyr/Kconfig
@@ -262,6 +262,12 @@ config SD_UPDATE_MOUNT_POINT
 	help
 		Indicates where the SD card will be mounted.
 
+config SD_UPDATE_DIRECTORY_NAME
+	string "Update directory"
+	default ""
+	help
+		Directory on the SD card where the image update is stored. Empty for root.
+
 config SD_UPDATE_IMAGE_FILE_NAME
 	string "Name of the image update file"
 	default "UPDATE.BIN"
diff --git a/boot/zephyr/include/sd_update.h b/boot/zephyr/include/sd_update.h
index 0a2e9b2c2..be5ecdc45 100644
--- a/boot/zephyr/include/sd_update.h
+++ b/boot/zephyr/include/sd_update.h
@@ -22,7 +22,7 @@ int write_update(struct sd_update *update);
 
 int revert_update();
 
-int cleanup_update(struct sd_update *update);
+int cleanup_update(struct sd_update *update, bool removeUpdate);
 
 bool do_sd_update();
 
diff --git a/boot/zephyr/sd_update.c b/boot/zephyr/sd_update.c
index 5a1ba9887..1ffd51153 100644
--- a/boot/zephyr/sd_update.c
+++ b/boot/zephyr/sd_update.c
@@ -14,8 +14,9 @@
 MCUBOOT_LOG_MODULE_REGISTER(sd_update);
 
 #define PATH_SEPARATOR "/"
-#define UPDATE_FILE CONFIG_SD_UPDATE_MOUNT_POINT PATH_SEPARATOR CONFIG_SD_UPDATE_IMAGE_FILE_NAME
-#define BACKUP_FILE CONFIG_SD_UPDATE_MOUNT_POINT PATH_SEPARATOR CONFIG_SD_UPDATE_BACKUP_FILE_NAME
+#define UPDATE_DIRECTORY CONFIG_SD_UPDATE_MOUNT_POINT PATH_SEPARATOR CONFIG_SD_UPDATE_DIRECTORY_NAME
+#define UPDATE_FILE UPDATE_DIRECTORY PATH_SEPARATOR CONFIG_SD_UPDATE_IMAGE_FILE_NAME
+#define BACKUP_FILE UPDATE_DIRECTORY PATH_SEPARATOR CONFIG_SD_UPDATE_BACKUP_FILE_NAME
 
 static FATFS fat_fs;
 /* mounting info */
@@ -65,9 +66,9 @@ int check_sd_update(struct sd_update *update) {
     static struct fs_dirent entry;
     bool has_update = false;
 
-    res = fs_opendir(&dirp, CONFIG_SD_UPDATE_MOUNT_POINT);
+    res = fs_opendir(&dirp, UPDATE_DIRECTORY);
     if (res) {
-        BOOT_LOG_ERR("Error opening dir %s [%d]\n", CONFIG_SD_UPDATE_MOUNT_POINT, res);
+        BOOT_LOG_ERR("Error opening dir %s [%d]\n", UPDATE_DIRECTORY, res);
         return res;
     }
 
@@ -88,6 +89,7 @@ int check_sd_update(struct sd_update *update) {
 
     if (!has_update) {
         BOOT_LOG_INF("No update file found on the SD card");
+        update->update_file.filep = NULL;
         return -ENOENT;
     }
 
@@ -397,8 +399,13 @@ int revert_update() {
     return res;
 }
 
-int cleanup_update(struct sd_update *update) {
-    fs_close(&update->update_file);
+int cleanup_update(struct sd_update *update, bool removeUpdate) {
+    if (update->update_file.filep != NULL) {
+        fs_close(&update->update_file);
+    }
+    if (removeUpdate) {
+        fs_unlink(UPDATE_FILE);
+    }
     return fs_unmount(&mp);
 }
 
@@ -444,7 +451,7 @@ bool do_sd_update() {
     }
 
 cleanup:
-    cleanup_update(&update);
+    cleanup_update(&update, updated);
     BOOT_LOG_INF("SD update finished");
     return updated;
 }

From 6fe25ce35773e2fe4dade7fabf205142145778b0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Luk=C3=A1=C5=A1=20Kopenec?= <lukas.kopenec@cloufield.cz>
Date: Wed, 22 Apr 2020 10:12:43 +0200
Subject: [PATCH 6/8] Document the SD update feature.

---
 docs/sd_update.md | 51 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 51 insertions(+)
 create mode 100644 docs/sd_update.md

diff --git a/docs/sd_update.md b/docs/sd_update.md
new file mode 100644
index 000000000..297cefd0c
--- /dev/null
+++ b/docs/sd_update.md
@@ -0,0 +1,51 @@
+# Updating firmware from an SD card
+
+## General
+
+The boot loader is able to update the firmware image from another flash partition or an SD card. The first option is available by default. The later one is currently only available for Zephyr and only supports the FAT file system. To enable this feature you need to add the following lines into the *prj.conf* in *boot/zephyr*:
+
+ - `CONFIG_MCUBOOT_SD_UPDATE=y` which automatically selects `CONFIG_FILE_SYSTEM` and `CONFIG_FAT_FILESYSTEM_ELM`
+ - enable SD card driver and related drivers, this depends on your board, example is given below
+ - depending on the drivers you may very probably need to enable multithreading by adding `CONFIG_MULTITHREADING=y`
+
+Besides that there are four optional config lines:
+
+ - `CONFIG_SD_UPDATE_MOUNT_POINT`: SD card mount point; default `"/SD:"`
+ - `CONFIG_SD_UPDATE_DIRECTORY_NAME`: Directory with update file on the SD card, `""` for root; default `""`
+ - `CONFIG_SD_UPDATE_IMAGE_FILE_NAME`: Name of the update file; default `"UPDATE.BIN"`
+ - `CONFIG_SD_UPDATE_BACKUP_FILE_NAME`: Name of the firmware backup file; default: `"BACKUP.BIN"`
+
+### Example of the lines added to prj.conf
+Below is a sample of the lines that needed to be added to the prj.conf on Nordic's NRF52 DK (nrf52dk_pca10040) to enable the SD card update. The loader will use Disk Access SDHC drivers and the SD card is connected to SPI2 which will be accessed using legacy SPI drivers because of [PAN58](https://infocenter.nordicsemi.com/index.jsp?topic=%2Ferrata_nRF52832_Rev2%2FERR%2FnRF52832%2FRev2%2Flatest%2Ferr_832.html).
+
+```KConfig
+### SPI SDHC drivers rely on multithreading
+CONFIG_MULTITHREADING=y
+
+CONFIG_MCUBOOT_SD_UPDATE=y
+
+CONFIG_SPI=y
+CONFIG_SPI_2=y
+CONFIG_NRFX_SPI2=y
+CONFIG_SPI_2_NRF_SPI=y
+CONFIG_DISK_ACCESS=y
+CONFIG_DISK_ACCESS_SDHC=y
+CONFIG_DISK_ACCESS_SPI_SDHC=y
+```
+
+## Preparing the update file
+Preparing the update file is simple, just build your application as usual, sign it using the [imgtool](./imgtool.md) name it according to `CONFIG_SD_UPDATE_IMAGE_FILE_NAME` (*update.bin* by default) and place it to the `CONFIG_SD_UPDATE_DIRECTORY_NAME` (root by default) on the SD card.
+
+**NOTE:** Only .bin files are currently supported, using the HEX format will result in a corrupted firmware.
+
+## Update process description
+Updating the firmware is done in the following steps:
+
+ 1. SD card is mounted under `CONFIG_SD_UPDATE_MOUNT_POINT`
+ 2. The `CONFIG_SD_UPDATE_DIRECTORY_NAME` directory is scanned for a file named `CONFIG_SD_UPDATE_IMAGE_FILE_NAME` if it is not found the process ends
+ 3. The file is open and its headers are loaded into memory
+ 4. Image SHA256 is validated against the hash stored in image TLVs
+ 5. Current firmware is backed up to `CONFIG_SD_UPDATE_BACKUP_FILE_NAME` file in the `CONFIG_SD_UPDATE_DIRECTORY_NAME` directory
+ 6. Slot 0 in flash is erased and rewritten with the new image; if a failure occurs the backup is flashed back
+ 7. After a successful update, the update file is deleted from the SD card
+ 8. Bootloader validates the written image, if the check fails, backup is flashed back
\ No newline at end of file

From 9b3b8169c5f432ddcdbb5e34099d55783ba412b0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Luk=C3=A1=C5=A1=20Kopenec?= <lukas.kopenec@cloufield.cz>
Date: Wed, 22 Apr 2020 10:39:45 +0200
Subject: [PATCH 7/8] Select DISK_ACCESS and DISK_ACCESS_SDHC for SD_UPDATE.

---
 boot/zephyr/Kconfig  | 2 ++
 boot/zephyr/prj.conf | 2 --
 docs/sd_update.md    | 6 ++----
 3 files changed, 4 insertions(+), 6 deletions(-)

diff --git a/boot/zephyr/Kconfig b/boot/zephyr/Kconfig
index 57b1199a6..d2d4cb689 100644
--- a/boot/zephyr/Kconfig
+++ b/boot/zephyr/Kconfig
@@ -249,6 +249,8 @@ source "subsys/logging/Kconfig.template.log_config"
 menuconfig MCUBOOT_SD_UPDATE
 	bool "MCUboot firmware update from SD card"
 	default n
+	select DISK_ACCESS
+	select DISK_ACCESS_SDHC
 	select FILE_SYSTEM
 	select FAT_FILESYSTEM_ELM
 	help
diff --git a/boot/zephyr/prj.conf b/boot/zephyr/prj.conf
index e096d9d81..c0d1741ae 100644
--- a/boot/zephyr/prj.conf
+++ b/boot/zephyr/prj.conf
@@ -58,6 +58,4 @@ CONFIG_SPI=y
 CONFIG_SPI_2=y
 CONFIG_NRFX_SPI2=y
 CONFIG_SPI_2_NRF_SPI=y
-CONFIG_DISK_ACCESS=y
-CONFIG_DISK_ACCESS_SDHC=y
 CONFIG_DISK_ACCESS_SPI_SDHC=y
diff --git a/docs/sd_update.md b/docs/sd_update.md
index 297cefd0c..a3a6336e6 100644
--- a/docs/sd_update.md
+++ b/docs/sd_update.md
@@ -4,8 +4,8 @@
 
 The boot loader is able to update the firmware image from another flash partition or an SD card. The first option is available by default. The later one is currently only available for Zephyr and only supports the FAT file system. To enable this feature you need to add the following lines into the *prj.conf* in *boot/zephyr*:
 
- - `CONFIG_MCUBOOT_SD_UPDATE=y` which automatically selects `CONFIG_FILE_SYSTEM` and `CONFIG_FAT_FILESYSTEM_ELM`
- - enable SD card driver and related drivers, this depends on your board, example is given below
+ - `CONFIG_MCUBOOT_SD_UPDATE=y` which automatically selects `CONFIG_DISK_ACCESS`, `CONFIG_DISK_ACCESS_SDHC`, `CONFIG_FILE_SYSTEM` and `CONFIG_FAT_FILESYSTEM_ELM`
+ - enable SD card and related drivers, this depends on your board, example is given below
  - depending on the drivers you may very probably need to enable multithreading by adding `CONFIG_MULTITHREADING=y`
 
 Besides that there are four optional config lines:
@@ -28,8 +28,6 @@ CONFIG_SPI=y
 CONFIG_SPI_2=y
 CONFIG_NRFX_SPI2=y
 CONFIG_SPI_2_NRF_SPI=y
-CONFIG_DISK_ACCESS=y
-CONFIG_DISK_ACCESS_SDHC=y
 CONFIG_DISK_ACCESS_SPI_SDHC=y
 ```
 

From efe97b6f6690dcdf1bfad547e6c85f4a9db72df0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Luk=C3=A1=C5=A1=20Kopenec?= <lukas.kopenec@cloufield.cz>
Date: Wed, 22 Apr 2020 11:07:24 +0200
Subject: [PATCH 8/8] Code style improvements.

---
 boot/zephyr/CMakeLists.txt      |  4 +---
 boot/zephyr/include/sd_update.h | 16 +++++++-------
 boot/zephyr/main.c              | 13 +++++------
 boot/zephyr/sd_update.c         | 38 +++++++++++++++++----------------
 4 files changed, 36 insertions(+), 35 deletions(-)

diff --git a/boot/zephyr/CMakeLists.txt b/boot/zephyr/CMakeLists.txt
index 1d6f8f361..009cbd51a 100644
--- a/boot/zephyr/CMakeLists.txt
+++ b/boot/zephyr/CMakeLists.txt
@@ -188,9 +188,7 @@ if(CONFIG_BOOT_ENCRYPT_EC256)
     )
 endif()
 
-if(CONFIG_MCUBOOT_SD_UPDATE)
-  zephyr_library_sources(sd_update.c)
-endif()
+zephyr_library_sources_ifdef(CONFIG_MCUBOOT_SD_UPDATE sd_update.c)
 
 if(CONFIG_MCUBOOT_SERIAL)
   zephyr_sources(${BOOT_DIR}/zephyr/serial_adapter.c)
diff --git a/boot/zephyr/include/sd_update.h b/boot/zephyr/include/sd_update.h
index be5ecdc45..267da5451 100644
--- a/boot/zephyr/include/sd_update.h
+++ b/boot/zephyr/include/sd_update.h
@@ -10,20 +10,20 @@ struct sd_update {
     struct fs_file_t update_file;
 };
 
-int init_sd();
+int sdu_init();
 
-int check_sd_update(struct sd_update *update);
+int sdu_check_update(struct sd_update *update);
 
-int validate_update_image(struct sd_update *update);
+int sdu_validate_update_image(struct sd_update *update);
 
-int backup_firmware();
+int sdu_backup_firmware();
 
-int write_update(struct sd_update *update);
+int sdu_write_update(struct sd_update *update);
 
-int revert_update();
+int sdu_revert_update();
 
-int cleanup_update(struct sd_update *update, bool removeUpdate);
+int sdu_cleanup(struct sd_update *update, bool removeUpdate);
 
-bool do_sd_update();
+bool sdu_do_update();
 
 #endif
diff --git a/boot/zephyr/main.c b/boot/zephyr/main.c
index 8b9ce65b7..a34cd17b6 100644
--- a/boot/zephyr/main.c
+++ b/boot/zephyr/main.c
@@ -18,6 +18,7 @@
 #include <zephyr.h>
 #include <drivers/gpio.h>
 #include <sys/__assert.h>
+#include <sys/util.h>
 #include <drivers/flash.h>
 #include <drivers/timer/system_timer.h>
 #include <usb/usb_device.h>
@@ -252,21 +253,21 @@ void main(void)
     }
 #endif
 
-#ifdef CONFIG_MCUBOOT_SD_UPDATE
-    bool updated = do_sd_update();
-#endif
+IF_ENABLED(CONFIG_MCUBOOT_SD_UPDATE, (
+    bool updated = sdu_do_update();
+))
 
     rc = boot_go(&rsp);
-    #ifdef CONFIG_MCUBOOT_SD_UPDATE
+    IF_ENABLED(CONFIG_MCUBOOT_SD_UPDATE, (
         if (rc != 0 && updated) {
             BOOT_LOG_INF("Failed to boot updated firmware, attemptin revert...");
-            int res = revert_update();
+            int res = sdu_revert_update();
             if (res == 0) {
                 BOOT_LOG_INF("Revert successful, booting original firmware");
                 rc = boot_go(&rsp);
             }
         }
-    #endif
+    ))
     if (rc != 0) {
         BOOT_LOG_ERR("Unable to find bootable image");
         while (1)
diff --git a/boot/zephyr/sd_update.c b/boot/zephyr/sd_update.c
index 1ffd51153..6f5615542 100644
--- a/boot/zephyr/sd_update.c
+++ b/boot/zephyr/sd_update.c
@@ -23,9 +23,10 @@ static FATFS fat_fs;
 static struct fs_mount_t mp = {
     .type = FS_FATFS,
     .fs_data = &fat_fs,
+    .mnt_point = CONFIG_SD_UPDATE_MOUNT_POINT,
 };
 
-int init_sd() {
+int sdu_init() {
     static const char *disk_pdrv = "SD";
     int err = disk_access_init(disk_pdrv);
 
@@ -34,7 +35,6 @@ int init_sd() {
         return err;
     }
 
-    mp.mnt_point = CONFIG_SD_UPDATE_MOUNT_POINT;
     err = fs_mount(&mp);
     if (err == FR_OK) {
         BOOT_LOG_INF("SD Card mounted");
@@ -50,13 +50,15 @@ int strcasecmp(const char *s1, const char *s2)
 	const unsigned char *us1 = (const unsigned char *)s1;
 	const unsigned char *us2 = (const unsigned char *)s2;
 
-	while (tolower(*us1) == tolower(*us2++))
-		if (*us1++ == '\0')
+	while (tolower(*us1) == tolower(*us2++)) {
+        if (*us1++ == '\0') {
 			return 0;
+        }
+    }
 	return tolower(*us1) - tolower(*--us2);
 }
 
-int check_sd_update(struct sd_update *update) {
+int sdu_check_update(struct sd_update *update) {
     if (!update) {
         return -EINVAL;
     }
@@ -218,7 +220,7 @@ static int tlv_iter_next(struct tlv_iterator *it, off_t *offset, uint16_t *type,
     return 1;
 }
 
-int validate_update_image(struct sd_update *update)
+int sdu_validate_update_image(struct sd_update *update)
 {
     uint8_t hash[32];
     uint8_t buf[32];
@@ -273,7 +275,7 @@ int validate_update_image(struct sd_update *update)
     return -1;
 }
 
-int backup_firmware() {
+int sdu_backup_firmware() {
     const struct flash_area *fap;
     size_t buf_size = 256;
     uint8_t buf[buf_size];
@@ -375,7 +377,7 @@ static int write_image(struct fs_file_t *file) {
     return res;
 }
 
-int write_update(struct sd_update *update) {
+int sdu_write_update(struct sd_update *update) {
     int res = fs_seek(&update->update_file, 0, FS_SEEK_SET);
     if (res) {
         BOOT_LOG_ERR("Failed to seek at the beggining of the update file (%d)", res);
@@ -385,7 +387,7 @@ int write_update(struct sd_update *update) {
     return write_image(&update->update_file);
 }
 
-int revert_update() {
+int sdu_revert_update() {
     struct fs_file_t backup;
     int res = fs_open(&backup, BACKUP_FILE);
     if (res) {
@@ -399,7 +401,7 @@ int revert_update() {
     return res;
 }
 
-int cleanup_update(struct sd_update *update, bool removeUpdate) {
+int sdu_cleanup(struct sd_update *update, bool removeUpdate) {
     if (update->update_file.filep != NULL) {
         fs_close(&update->update_file);
     }
@@ -409,38 +411,38 @@ int cleanup_update(struct sd_update *update, bool removeUpdate) {
     return fs_unmount(&mp);
 }
 
-bool do_sd_update() {
+bool sdu_do_update() {
     BOOT_LOG_INF("Starting SD update...");
     int res;
     struct sd_update update;
     bool updated = false;
 
-    res = init_sd();
+    res = sdu_init();
     if (res) {
         return updated;
     }
 
-    res = check_sd_update(&update);
+    res = sdu_check_update(&update);
     if (res) {
         goto cleanup;
     }
 
-    res = validate_update_image(&update);
+    res = sdu_validate_update_image(&update);
     if (res) {
         BOOT_LOG_ERR("Failed update image validation (%d)", res);
         goto cleanup;
     }
 
-    res = backup_firmware();
+    res = sdu_backup_firmware();
     if (res) {
         BOOT_LOG_ERR("Could not backup current firmware, update won't continue. (%d)", res);
         goto cleanup;
     }
 
-    res = write_update(&update);
+    res = sdu_write_update(&update);
     if (res) {
         BOOT_LOG_WRN("Failed to write update, attempting revert...");
-        res = revert_update();
+        res = sdu_revert_update();
         if (res) {
             BOOT_LOG_ERR("Revert failed");
         } else {
@@ -451,7 +453,7 @@ bool do_sd_update() {
     }
 
 cleanup:
-    cleanup_update(&update, updated);
+    sdu_cleanup(&update, updated);
     BOOT_LOG_INF("SD update finished");
     return updated;
 }
